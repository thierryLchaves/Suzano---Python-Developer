# 5 .Interfaces e Classes Abstratas com Python
## Sumário 

- [Variáveis de classe e Variáveis de instância ](#1-variáveis-de-classe-e-variáveis-de-instância)
- [Métodos de classe e Métodos estático](#2-métodos-de-classe-e-métodos-estático)
- [O que são Interfaces ](#3-o-que-são-interfaces)
- [Classes Abstratas](#4-classes-abstratas)
---
## 1. Variáveis de classe e Variáveis de instância 
### Objetivo Geral 
Entender as diferenças entre variáveis de classe e variáveis de instância. 
#### O que são e como utilizamos
__Atributos do objeto__  
Todos os objetos nascem com o mesmo número de atributos de classe e de instância. Atributos de instância são diferentes para cada objeto (cada objeto tem uma cópia), ja os atributos de classe são compartilhados entre os objetos  

```py 
class Estudate:
    escola = "DIO"

    def __init__(self, nome, numero):
        self.nome = nome
        self.numero = numero 

    def __str__(self):
        return f"{self.nome} ({self.numero}) - {self.escola}"
    
def mostrar_valores(*objs):
    for obj in objs:
        print(obj)


aluno_1 = Estudate("Thierry",1)
aluno_2 = Estudate("Tyara",2)
mostrar_valores(aluno_1,aluno_2)


Estudate.escola = "Python"
aluno_3 = Estudate("Larissa", 3)
mostrar_valores(aluno_1,aluno_2,aluno_3)

```

---
## 2. Métodos de classe e Métodos estático 
### Objetivo Geral s
Entender as diferenças entre métodos de classe e métodos estáticos. 

#### O que são e como utilizamos
__Métodos de classe__  
Métodos de classe estão ligados à classe e não ao objeto. Eles tem acesso ao estado da classe, pois recebem um parâmetro que aponta para a a classe e não para a instância do objeto.  Por convenção os métodos de classe recebe como primeiro argumentos "parâmetro" cls ao invés de self.  

__Métodos estáticos__  
Um método estático não recebe um primeiro argumento explícito. Ele também é um método vinculado à classe e não ao objeto da classe. Este método não pode acessar ou modificar o estado da classe. Ele está presente em uma classe porque faz sentido que o método esteja presente na classe.  
__Métodos de classe X Métodos estáticos__  
- Um método de classe recebe um primeiro parâmetro que aponta para a classe, enquanto um método estático não. 
- Um método de classe pode acessar ou modificar o estado da classe enquanto um método estático não pode acessá-lo ou modificá-lo.  

__Quando utilizar método de classe ou estático__  
- Geralmente usamos o método de classe para criar métodos de fábrica. 
    - Métodos de fábrica geralmente são métodos que retornam instâncias daquela classe. Ou seja se tenho uma classe pessoa por exemplo caso crie um método de fábrica para pessoa, esse método terá como retorno uma nova instância do tipo pessoa. 
- Geralmente usamos métodos estáticos para criar funções utilitárias.  
    - Então normalmente criamos métodos estáticos para validações de classe, exemplo dentro de uma classe denominada de pessoa, e desejo criar um método que valide por exemplo a maioridade da pessoa, esse método será um método utilitário. 

```py
class Pessoa:

    def __init__(self, nome, idade):
        self.nome = nome
        self.idade = idade

    def criar_de_data_nascimento(self, ano, mes, dia, nome):
        idade = 2022 - ano
        return Pessoa(nome, idade)


# p = Pessoa("Thierry", 29)

# print(p.nome, p.idade)

p2 = Pessoa().criar_de_data_nascimento(1996, 1, 26, "Thierry")
print(p2.nome, p2.idade)
```
No exemplo do código acima o código em sí funcionária, porém o que o esse código está fazendo não seria o mais correto, pois quando o declaramos conforme descrito acima, o que o `PYTHON` irá realizar na prática é:
1. Criar uma instância do tipo pessoa. 
2. Executar o método criar_de_data_nascimento
3. E como o método está retornando um novo objeto será criado novamente mais  um objeto do método pessoa. 

Isso causa um tipo de "redundância" desnecessária dentro do seu código. Visando melhorar esse processo, qual é a melhor prática a ser adotada ? Criar um método de classe, para tal utilizamos um decorador chamado de  `@classmethod`, esse decorador  então irá transformar nosso método em um método de classe, além disso por convenção o primeiro argumento a ser utilizado nesse tipo de método ou seja o primeiro parâmetro deixa de ser `self` e passa a ser `cls`, para validar o que foi descrito podemos comprovar o com o seguinte código:
```py
class Pessoa:

    def __init__(self, nome, idade):
        self.nome = nome
        self.idade = idade

    @classmethod
    def criar_de_data_nascimento(cls, ano, mes, dia, nome):
        print(cls)

p2 = Pessoa.criar_de_data_nascimento(1996, 1, 26, "Thierry")

```
Quando executado o código acima termos o seguinte retorno no terminal:
```bash
tlchaves@tlchaves:~/Documentos/Estudos/DIO/Suzado_Bootcamp/Suzano---Python-Developer/04-Programação Orientada a Objetos com Python/5-Interfaces e Classes Abstratas com Pyt
hon$ /bin/python3 "/home/tlchaves/Documentos/Estudos/DIO/Suzado_Bootcamp/Suzano---Python-Developer/04-Programação Orientada a Objetos com Python/5-Interfaces e Classes Abstratas com Python/src/02_metodos_classe_estatico.py"
<class '__main__.Pessoa'>
```
Notamos então que o retorno do método é um objeto da classe do tipo `pessoa`que é o nome da classe em questão.  então quando ajustamos o método para que o seu retorno seja como `cls(nome, idade)`, dispensando assim a nova instância de pessoa, pois como cls é um referência a classe, resolvemos o problema de múltiplas instancias do mesmo objeto, ficando da seguinte forma:
```py
class Pessoa:

    def __init__(self, nome, idade):
        self.nome = nome
        self.idade = idade

    @classmethod
    def criar_de_data_nascimento(cls, ano, mes, dia, nome):

        idade = 2022 - ano
        return cls(nome, idade)

p2 = Pessoa.criar_de_data_nascimento(1996, 1, 26, "Thierry")
print(p2.nome, p2.idade)
```

Agora quando queremos criar um método estático como realizamos essa declaração ? Para tal utilizamos o decorador `@staticmethod`, esse decorador irá determinar que a função que está sendo criada será uma função estática. Conforme exemplificamos no texto acima, criaremos um método estático para validar a maioridade de uma pessoa na classe pessoa
```py
    @staticmethod
    def e_maior_idade(idade):
        return idade >= 18
print(Pessoa.e_maior_idade(18))
print(Pessoa.e_maior_idade(8))
```
Com o código acima a função em questão será executada para pessoa e irá validar se conforme o argumento passado o retorno será `TRUE OR FLASE` 

Então para incutir o que foi descrito. 

<div style="border-left: 4px solid red; background-color:rgb(22, 23, 24); padding: 10px;">
  <strong style="color: red;">Quando utilizar um método de classe</strong>
   <p> Quando for preciso ter acesso ao contexto da classe, ou seja a aplicação do método a ser criado, </br>
   depende de informações ou retornos próprios da classe, no exemplo criar_de_data_nascimento. </br>
   Esse método só faz sentido pois ele leva em consideração uma instância do objeto e informações desse objeto a ser instanciado</br>
   </p>
</div>

---

<div style="border-left: 4px solid red; background-color:rgb(22, 23, 24); padding: 10px;">
  <strong style="color: red;">Quando utilizar um método de estáticos</strong>
   <p> Quando não é necessário aplicação do contexto da classe, ou da instância daquele objeto, então será melhor optar por um método estático.
   </br>
   </p>
</div>

[código](src/02_metodos_casse_estatico.py)
--- 
## 3. O que são Interfaces 
### Objetivo Geral 
Aprender o conceito de contrato e como podemos utilizar classes abstratas em Python para implementá-los. 
### O que são interfaces ?

<div style="border-left: 4px solid red; background-color:rgb(22, 23, 24); padding: 10px;">
  <strong style="color: red;">Importante</strong>
   <p> Interfaces definem o que uma classe deve fazer e não como. </p>
</div>

Então quando pensamos em um contexto de interfaces em um contexto geral, uma interface é uma forma que todos que desejam implementar algo seguiram aquele padrão e terão um determinado resultado final. Então se pensarmos numa abstração de lapiseira, sua interface prega que esse objeto deverá ter um local para colocar o grafite, e algum mecanismo para que quando acionado esse grafite fique pronto para uso. Então esse ""contrato", nos garante __N__ variações de lapiseira, que independem da sua cor da maneira que o grafite é inserido e etc...  Então sempre que definimos um padrão do que se fazer isso na programação pode ser nomeado de interface.

### Python  tem interface ?
O conceito de interface é definir um contrato, onde são declarados os métodos ( o que deve ser feito) e suas respectivas assinaturas. Em python utilizamos classes abstratas para criar contratos. Classes abstratas não podem ser instanciadas. Diferentemente do `JAVA` no qual não se é possível realizar heranças múltiplas, temos por exemplo a aplicação de uma interface por intermédio da palavra reservada interface, na qual auxilia a ideia de herança de múltiplas classes. Mas como em python é permitido herança múltipla , é possível criar classes abstratas para que seja realizado a extensão n vezes.

--- 
## 4. Classes Abstratas
### Criando classes abstratas com o módulo ABC
Por padrão, o Python não fornece classes abstratas. O Python vem com um módulo que fornece base para definir as classes abstratas, e o nome do módulo é __ABC (ABSTRACT BASE CLASS)__ . O ABC funcionando decorando métodos da classe base como abstratos e, em seguida, registrando classes concretas como implementações da base abstrata. Um método se torna abstrato quando decorado com o `@abstractmethod`. 
Para realizamos essa implementação devemos iniciar o código com a importação do módulo/biblioteca ABC esse é feito da seguinte maneira:
```py
from abc import ABC
```

Mas somente isso não é o suficiente, para que a implementação de uma classe abstrata funcione corretamente devemos entender nossa classe com esse método ABC, novamente lembrando do conceito de [Interfaces](#o-que-são-interfaces-), quando esse método estabelecerá um contrato com o módulo ABC, para que sua implementação seja realizada, outro ponto valido de ser ressaltado e o "significado" de um método abstrato que nada mais é que uma forma de obrigatoriedade para todas as classes filhas serão obrigadas a realizar sua implementação, outro ponto e que esse método pode ou não ter um corpo. 
Outro ponto válido de ser ressaltado novamente é que uma classe abstrata não pode ser instanciada diretamente. E no que diz respeito a implementação diretamente de uma um método abstrato após realizar o processo de extensão do módulo ABC devemos realizar a adição do decorador `abstractmethod`. O exemplo abaixo vemos uma maneira de realizar essa implementação. 
<div style="border-left: 4px solid red; background-color:rgb(22, 23, 24); padding: 10px;">
  <strong style="color: red;">IMPORTANTE</strong>
   <p> Quando possuímos um método abstrato dentro de uma classe a classe em questão torna-se abastrata o que impedirá realizar a instância da classe em questão. 
   </br>
   </p>
</div>

```py
from abc import ABC, abstractmethod

class ControleRemoto(ABC):
    @abstractmethod
    def ligar(self):
        pass
    @abstractmethod
    def desligar(self):
        pass

class ControleTV(ControleRemoto):
    pass

controle = ControleTV()
controle.ligar()
controle.desligar()

```
Porém se tentarmos rodar o código será nos retornado um erro pois conforme descrito os métodos abstratos são de implementação obrigatória nas classes. filhas. Caso tentarmos rodar o código nos será retornado uma mensagem de erro :
```bash
Traceback (most recent call last):
  File "/home/tlchaves/Documentos/Estudos/DIO/Suzado_Bootcamp/Suzano---Python-Developer/04-Programação Orientada a Objetos com Python/5-Interfaces e Classes Abstratas com Python/src/03_classe_abastrata.py", line 19, in <module>
    controle = ControleTV()
               ^^^^^^^^^^^^
TypeError: Can't instantiate abstract class ControleTV without an implementation for abstract methods 'desligar', 'ligar'
```
O erro em questão está nos dizendo que não é possível realizar a instância da classe ControleTV pois como essa descende de ControleRemoto o que por sua vez está implementado dois métodos abstratos  `'desligar', 'ligar' `  
Para que possamos sanar esse método então devemos criar os 2 métodos mencionados. 
```py 
from abc import ABC, abstractmethod


class ControleRemoto(ABC):

    @abstractmethod
    def ligar(self):
        pass

    @abstractmethod
    def desligar(self):
        pass


class ControleTV(ControleRemoto):

    def ligar(self):
        print("Ligando a TV...")
        print("Liganda!")

    def desligar(self):
        print("Desligando a TV...")
        print("Desliganda!")


controle = ControleTV()

controle.ligar()
controle.desligar()
```
Com isso inferimos o seguinte, diferentemente do que foi visto de quando apenas realizamos a implementação de extensão via herança na qual é possível realizar a implementação ou não de métodos existentes na classe PAI, quando trabalhamos com o conceito de contratos/interfaces, e essas interfaces contém métodos abstratos faz-se necessário a realização da implementação desses métodos nas classes herdeiras. O que de certa maneira que independente da classe a ser criada caso essa descenda de uma classe contratada, ela será __obrigada__ a implementar os métodos abstratos dessa classe pai, o que acarreta por exemplo em uma segurança maior quando aplicarmos o conceito de polimorfismo em um objeto/classe, pois quando realizamos apenas a extensão dessa classe caso não implementarmos um método padrão da classe pai o código irá funcionar, porém ao aplicar uma implementação de um método abstrato nós temos a garantia de que aquele método necessariamente será implementado, o que acarreta a fim de que com essa garantia caso necessário aquela nova implementação do método não seja idêntica ao implementação da classe herdada.   

Outro ponto que podemos realizar dentro da implementação de uma classe abstrata seria "forçar" a implementação de uma propriedade de uma determinada classe, e isso é feito da seguinte maneira. 
```py
    @property
    @abstractproperty
    def marca(self):
        pass
```
Com esses decoradores, dizemos que todas as classes que herdem da nossa classe abstrata, devem implementar essa propriedade. Com essa implementações deixamos o código da seguinte maneira:
```py
from abc import ABC, abstractmethod, abstractproperty


class ControleRemoto(ABC):

    @abstractmethod
    def ligar(self):
        pass

    @abstractmethod
    def desligar(self):
        pass

    @property
    @abstractproperty
    def marca(self):
        pass


class ControleTV(ControleRemoto):

    def ligar(self):
        print("Ligando a TV...")
        print("Liganda!")

    def desligar(self):
        print("Desligando a TV...")
        print("Desliganda!")

    @property
    def marca(self):
        return "Philco"


class ControleArCondicionado(ControleRemoto):

    def ligar(self):
        print("Ligando o Ar Condicionado...")
        print("Liganda!")

    def desligar(self):
        print("Desligando o Ar Condicionado...")
        print("Desligando!")

    @property
    def marca(self):
        return "LG"


controle = ControleTV()

controle.ligar()
controle.desligar()
print(controle.marca)


controle = ControleArCondicionado()
controle.ligar()
controle.desligar()
print(controle.marca)
```
=======
Aprender o conceito de contrato e como podemos utilizar classes abstratas em Python para implementá-los.

#### O que são interfaces ?
__Importante__  
Interfaces definem o que uma classe deve fazer e não como.  

__Python tem interface?__  
O conceito de interface é definir um contrato, onde são declarados os métodos (o que deve ser feito) e suas respectivas assinaturas. Em Python utilizamos classes abstratas para criar contratos. Classes abstratas não podem ser instanciadas. b
--- 
## 4. Classes Abstratas
#### Criando classes abstratas com o módulo abc
__ABC__  
Por padrão, o Python não fornece classes abstratas. O Python vem com um módulo que fornece a base para definir as classes abstratas, e o nome do módulo é ABC. O ABC funciona decorando métodos da classe base como abstratos e, em seguida, registrando classes concretas como implementações da base abstrata. Um método se torna abstrato quando decorado com @abstractmethod. 


--- 
### Links Uteis
- [Trilha no git](https://github.com/digitalinnovationone/trilha-python-dio)
- [Documentação módulo ABC](https://doc.python.org/pt-br/3/library/abc.html)
---
As respostas da aula 5 estão [aqui](IMGS)


<table style="text-align: center; width: 100%;"> 
<caption><b>Skils do projeto </b></caption>
<tr>
    <td style="text-align: center;">
    <img alt="Markdown" src="https://img.shields.io/badge/markdown-%23000000.svg?style=for-the-badge&logo=markdown&logoColor=white"/>
    </td>
    <td style="text-align: center;">
    <img alt="Python" src="https://img.shields.io/badge/python-3670A0?style=for-the-badge&logo=python&logoColor=ffdd54"/>
    </td>
    <td style="text-align: center;">
    <img alt="VSCode" src="https://img.shields.io/badge/Visual%20Studio%20Code-0078d7.svg?style=for-the-badge&logo=visual-studio-code&logoColor=white"/>
    </td>
<tr> 
</table>

---
Titulo: 5 .Interfaces e Classes Abstratas com Python 

Autor: Thierry Lucas Chaves

Data criacao: 03/06/2025

Data modificacao: 01/09/2025

Versao: 1.0  

---